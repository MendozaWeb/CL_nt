30%    Programación Reactiva (rxjava2)     
20%    Programación Funcional (java8+) 
30%    Pruebas Unitarias   
40%    Spring (FWK/boot)   
10%    Clean Code/Solid/POO    
40%    Patrones de Diseño Java 
30%    Git/Sonarqube/Fortify/Jenkins    

Esto me preguntaron en una entrevista, para poder trabajar para el sector bancario: JVM/JRE/JDK »  
Inmutabilidad » 
Autoboxing/Boxing »
Modificadores de Acceso »
Estructuras de Datos »
Error vs Excepción (Checked/Unchecked) »
Algoritmos de Búsqueda/Ordenamiento » 
Reflection vs Introspection »

» Overloading/Overriding » 
Uso de Herencia » Uso de Encapsulación » Uso de Polimorfismo » Uso de Abstracción » 
Uso de Generics<T> » Anonymous Inner Classes / Static Nested Class / Local Inner Classes »
 Single Responsibility Principle » Open/Closed Principle » Liskov’s Substitution Principle » 
 Interface Segregation Principle » Dependency Inversion Principle » Patrón de diseño fábrica » 
 Patrón de diseño fachada » Patrón de diseño singleton » Patrón de diseño mvc » Patrón de diseño DI » 
 Patrón de diseño DAO » Patrón de diseño Repository » Patrón de diseño Strategy

 » Default Method in Interface » Static Method in Interface » Functional Interface » 
 Lambda Expressions » Predicate » Function » Consumer » Supplier » Method References » Stream API » Clase Optional


 » Load Balancing » Service Discovery » Fault Tolerance » Api Gateway » 
 Uso de Eventos Síncronos/Asíncronos » Escalabilidad » Config Server » Distributed Tracing » Orquestación/Coreografía

 » Semántica y taxonomía de Apis » Diseño Dirigido por Dominio (DDD) » Patrón CQRS » Patrón SAGA » 
 Nivel de madurez de ApiREST » Patrón Strangler » Seguridad en Apis » Patrón Circuit Breaker » Patrón sub/pub

 » Futures & Promises (Limitations) » Callbacks (Limitations) » Clase CompletableFuture (Limitations) » Patrón de diseño Observer » Patrón de diseño Iterator » RxJava 2.x » 
 Project Reactor » Akka Streams » Manejo de pruebas unitarias reactivas » Operadores de Transformación » Uso de R2DBC » Backpressure


 » Spring Initializer » Swagger/OpenApi » Spring Data » Spring Security » Spring Boot » Manejo de trazas con Logback

 » Spring Cloud » Uso de Docker/Kubernetes » Uso de tópicos con Kafka/RabbitMQ » Uso de Cache Redis/Hazelcast


 » Configuración y despliegue de microsevicios en Cloud (Azure) » Conectando nuestros microservicios (gitflow, Groovy, GitHub Actions) » 
 Configurando y ejecutando Serverless (FaaS) » Uso de herramientas de tracing y monitoring

 » Uso de lombok » Librerías de pruebas unitarias (JUnit 5, Mockito, MockWebServer) » Implementación de métricas de calidad con SonarQube/Fortify » 
 Cobertura y análisis de pruebas unitarias (JaCoCo/Checkstyle/Spotbugs) » Construcción de software basado en TDD


 





 ARC AZURE, JAVA AWS
 TOGANG 
 PATRONES DE DISEÑO
 


 Esto me preguntaron en una entrevista, para poder trabajar para el sector bancario: JVM/JRE/JDK »  
Inmutabilidad » 
Autoboxing/Boxing »
Modificadores de Acceso »
Estructuras de Datos »
Error vs Excepción (Checked/Unchecked) »
Algoritmos de Búsqueda/Ordenamiento » 
Reflection vs Introspection »

» Overloading/Overriding » 
Uso de Herencia » Uso de Encapsulación » Uso de Polimorfismo » Uso de Abstracción » 
Uso de Generics<T> » Anonymous Inner Classes / Static Nested Class / Local Inner Classes »
 Single Responsibility Principle » Open/Closed Principle » Liskov’s Substitution Principle » 
 Interface Segregation Principle » Dependency Inversion Principle » Patrón de diseño fábrica » 
 Patrón de diseño fachada » Patrón de diseño singleton » Patrón de diseño mvc » Patrón de diseño DI » 
 Patrón de diseño DAO » Patrón de diseño Repository » Patrón de diseño Strategy

 » Default Method in Interface » Static Method in Interface » Functional Interface » 
 Lambda Expressions » Predicate » Function » Consumer » Supplier » Method References » Stream API » Clase Optional


 » Load Balancing » Service Discovery » Fault Tolerance » Api Gateway » 
 Uso de Eventos Síncronos/Asíncronos » Escalabilidad » Config Server » Distributed Tracing » Orquestación/Coreografía

 » Semántica y taxonomía de Apis » Diseño Dirigido por Dominio (DDD) » Patrón CQRS » Patrón SAGA » 
 Nivel de madurez de ApiREST » Patrón Strangler » Seguridad en Apis » Patrón Circuit Breaker » Patrón sub/pub

 » Futures & Promises (Limitations) » Callbacks (Limitations) » Clase CompletableFuture (Limitations) » Patrón de diseño Observer » Patrón de diseño Iterator » RxJava 2.x » 
 Project Reactor » Akka Streams » Manejo de pruebas unitarias reactivas » Operadores de Transformación » Uso de R2DBC » Backpressure


 » Spring Initializer » Swagger/OpenApi » Spring Data » Spring Security » Spring Boot » Manejo de trazas con Logback

 » Spring Cloud » Uso de Docker/Kubernetes » Uso de tópicos con Kafka/RabbitMQ » Uso de Cache Redis/Hazelcast


 » Configuración y despliegue de microsevicios en Cloud (Azure) » Conectando nuestros microservicios (gitflow, Groovy, GitHub Actions) » 
 Configurando y ejecutando Serverless (FaaS) » Uso de herramientas de tracing y monitoring

 » Uso de lombok » Librerías de pruebas unitarias (JUnit 5, Mockito, MockWebServer) » Implementación de métricas de calidad con SonarQube/Fortify » 
 Cobertura y análisis de pruebas unitarias (JaCoCo/Checkstyle/Spotbugs) » Construcción de software basado en TDD